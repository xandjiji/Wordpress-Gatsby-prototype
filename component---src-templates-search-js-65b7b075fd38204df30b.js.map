{"version":3,"sources":["webpack:///./src/components/common/SearchBar/SearchBar.styled.js","webpack:///./src/components/common/SearchBar/index.js","webpack:///./node_modules/js-search/dist/esm/js-search.js","webpack:///./src/templates/Search.js","webpack:///./src/components/common/PostGrid/PostGrid.styled.js","webpack:///./src/components/common/PostCard/PostCard.styled.js","webpack:///./src/components/common/PostCard/index.js","webpack:///./src/components/common/PostGrid/index.js","webpack:///./src/components/common/PageHero/PageHero.styled.js","webpack:///./src/components/common/PageHero/index.js","webpack:///./src/images/search.svg"],"names":["styled","div","SearchBar","onChangeHook","useState","term","setTerm","htmlFor","id","placeholder","onChange","event","target","value","handleChange","onKeyDown","key","navigate","handleKey","to","PrefixIndexStrategy","prototype","expandToken","token","expandedTokens","string","i","length","charAt","push","LowerCaseSanitizer","sanitize","text","toLocaleLowerCase","trim","getNestedFieldValue","object","path","TfIdfSearchIndex","uidFieldName","this","_uidFieldName","_tokenToIdfCache","_tokenMap","_proto","indexDocument","uid","doc","tokenDatum","tokenMap","$numDocumentOccurrences","$totalNumOccurrences","$uidMap","uidMap","$document","$numTokenOccurrences","search","tokens","corpus","uidToDocumentMap","numTokens","tokenMetadata","j","numKeys","keys","Object","documents","calculateTfIdf","_createCalculateTfIdf","sort","documentA","documentB","_createCalculateIdf","tokenToIdfCache","numDocumentsWithToken","Math","log","calculateIdf","document","score","inverseDocumentFrequency","Infinity","Array","REGEX","SimpleTokenizer","tokenize","split","filter","_defineProperties","props","descriptor","enumerable","configurable","writable","defineProperty","Search","Error","_indexStrategy","_searchIndex","_sanitizer","_tokenizer","_documents","_searchableFields","Constructor","protoProps","staticProps","addDocument","addDocuments","concat","indexDocuments_","addIndex","field","query","_initialized","indexStrategy","sanitizer","searchIndex","tokenizer","di","numDocuments","sfi","numSearchableFields","fieldValue","searchableField","toString","fieldTokens","fti","numFieldValues","fieldToken","eti","nummExpandedTokens","expandedToken","set","get","pageContext","searchResults","setSearchResults","searcher","setSearcher","useEffect","queryString","URLSearchParams","location","substring","postArray","postData","allPosts","forEach","element","node","JsSearch","MasterLayout","PageHero","newTerm","PostGrid","title","itemArray","itemsPerPage","PostCard","post","link","featured_media","categories","excerpt","getPathname","className","fluid","localFile","childImageSharp","alt","alt_text","map","item","name","dangerouslySetInnerHTML","__html","undefined","slicePosts","index","slice","setIndex","postList","setPostlist","handleSetIndex","newValue","MaterialContainer","labelTag","container","onClick","ceil","currentItem","h2","React","createElement","defaultProps","module","exports","default"],"mappings":"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","file":"component---src-templates-search-js-65b7b075fd38204df30b.js","sourcesContent":["import styled from 'styled-components';\n\nexport default styled.div`\n    margin-top: 36px;\n    margin-left: 40px;\n    margin-right: 40px;\n\n    @media(min-width: 768px) {\n        margin-left: 80px;\n        margin-right: 80px;\n    }\n\n    @media(min-width: 1024px) {\n        margin-left: 140px;\n        margin-right: 140px;\n    }\n\n    @media(min-width: 1440px) {\n        margin-right: calc((100vw - 1200px) / 2);\n        margin-left: calc((100vw - 1200px) / 2);\n    }\n\n    @media(min-width: 1880px) {\n        margin-right: calc((100vw - 1600px) / 2);\n        margin-left: calc((100vw - 1600px) / 2);\n    }\n\n    display: flex;\n    align-items: center;\n    border-radius: 5px;\n    border: solid 1px #B4B4B4;\n    box-shadow: 2px 2px 4px 2px rgba(0,0,0,0.14);\n    overflow: hidden;\n\n    label {\n        position: absolute;\n        z-index: -1;\n    }\n\n    input {\n        padding: 6px 16px;\n        width: 100%;\n        box-sizing: border-box;\n        flex-grow: 1;\n        outline: none;\n        border: none;\n    }\n\n    a {\n        display: flex;\n        padding: 7px 12px;\n        background-color: #3F51B5;\n        font-size: 12px;\n        color: #fff;\n\n        svg {\n            margin-left: 6px;\n        }\n    }\n`;","import React, { useState } from 'react';\nimport { Link, navigate } from 'gatsby';\nimport SearchBarStyle from './SearchBar.styled';\n\nimport SearchIcon from '../../../images/search.svg';\n\nconst SearchBar = ({ onChangeHook }) => {\n\n    const [term, setTerm] = useState(null);\n\n    const handleChange = (event) => {\n        setTerm(event.target.value);\n        if (onChangeHook) {\n            onChangeHook(event.target.value);\n        }\n    }\n\n    const handleKey = (event) => {\n        if (event.key === 'Enter' && term) {\n            navigate(`/search?s=${term}`);\n        }\n    }\n\n    return (\n        <SearchBarStyle>\n            <label htmlFor=\"term\">test</label>\n            <input\n                id=\"term\"\n                placeholder=\"Search for keywords like: 'photo', 'selfie', 'post'\"\n                onChange={(event) => handleChange(event)}\n                onKeyDown={(event) => handleKey(event)}\n            />\n\n            <Link to={`${term ? `/search?s=${term}` : '/'}`}>\n                Search\n                <SearchIcon />\n            </Link>\n        </SearchBarStyle>\n    );\n}\n\nexport default SearchBar;","/**\n * Indexes for all substring searches (e.g. the term \"cat\" is indexed as \"c\", \"ca\", \"cat\", \"a\", \"at\", and \"t\").\n */\nvar AllSubstringsIndexStrategy = /*#__PURE__*/function () {\n  function AllSubstringsIndexStrategy() {}\n\n  var _proto = AllSubstringsIndexStrategy.prototype;\n  /**\n   * @inheritDocs\n   */\n\n  _proto.expandToken = function expandToken(token) {\n    var expandedTokens = [];\n    var string;\n\n    for (var i = 0, length = token.length; i < length; ++i) {\n      string = '';\n\n      for (var j = i; j < length; ++j) {\n        string += token.charAt(j);\n        expandedTokens.push(string);\n      }\n    }\n\n    return expandedTokens;\n  };\n\n  return AllSubstringsIndexStrategy;\n}();\n/**\n * Indexes for exact word matches.\n */\n\n\nvar ExactWordIndexStrategy = /*#__PURE__*/function () {\n  function ExactWordIndexStrategy() {}\n\n  var _proto = ExactWordIndexStrategy.prototype;\n  /**\n   * @inheritDocs\n   */\n\n  _proto.expandToken = function expandToken(token) {\n    return token ? [token] : [];\n  };\n\n  return ExactWordIndexStrategy;\n}();\n/**\n * Indexes for prefix searches (e.g. the term \"cat\" is indexed as \"c\", \"ca\", and \"cat\" allowing prefix search lookups).\n */\n\n\nvar PrefixIndexStrategy = /*#__PURE__*/function () {\n  function PrefixIndexStrategy() {}\n\n  var _proto = PrefixIndexStrategy.prototype;\n  /**\n   * @inheritDocs\n   */\n\n  _proto.expandToken = function expandToken(token) {\n    var expandedTokens = [];\n    var string = '';\n\n    for (var i = 0, length = token.length; i < length; ++i) {\n      string += token.charAt(i);\n      expandedTokens.push(string);\n    }\n\n    return expandedTokens;\n  };\n\n  return PrefixIndexStrategy;\n}();\n/**\n * Enforces case-sensitive text matches.\n */\n\n\nvar CaseSensitiveSanitizer = /*#__PURE__*/function () {\n  function CaseSensitiveSanitizer() {}\n\n  var _proto = CaseSensitiveSanitizer.prototype;\n  /**\n   * @inheritDocs\n   */\n\n  _proto.sanitize = function sanitize(text) {\n    return text ? text.trim() : '';\n  };\n\n  return CaseSensitiveSanitizer;\n}();\n/**\n * Sanitizes text by converting to a locale-friendly lower-case version and triming leading and trailing whitespace.\n */\n\n\nvar LowerCaseSanitizer = /*#__PURE__*/function () {\n  function LowerCaseSanitizer() {}\n\n  var _proto = LowerCaseSanitizer.prototype;\n  /**\n   * @inheritDocs\n   */\n\n  _proto.sanitize = function sanitize(text) {\n    return text ? text.toLocaleLowerCase().trim() : '';\n  };\n\n  return LowerCaseSanitizer;\n}();\n/**\n * Find and return a nested object value.\n *\n * @param object to crawl\n * @param path Property path\n * @returns {any}\n */\n\n\nfunction getNestedFieldValue(object, path) {\n  path = path || [];\n  object = object || {};\n  var value = object; // walk down the property path\n\n  for (var i = 0; i < path.length; i++) {\n    value = value[path[i]];\n\n    if (value == null) {\n      return null;\n    }\n  }\n\n  return value;\n}\n/**\n * Search index capable of returning results matching a set of tokens and ranked according to TF-IDF.\n */\n\n\nvar TfIdfSearchIndex = /*#__PURE__*/function () {\n  function TfIdfSearchIndex(uidFieldName) {\n    this._uidFieldName = uidFieldName;\n    this._tokenToIdfCache = {};\n    this._tokenMap = {};\n  }\n  /**\n   * @inheritDocs\n   */\n\n\n  var _proto = TfIdfSearchIndex.prototype;\n\n  _proto.indexDocument = function indexDocument(token, uid, doc) {\n    this._tokenToIdfCache = {}; // New index invalidates previous IDF caches\n\n    var tokenMap = this._tokenMap;\n    var tokenDatum;\n\n    if (typeof tokenMap[token] !== 'object') {\n      tokenMap[token] = tokenDatum = {\n        $numDocumentOccurrences: 0,\n        $totalNumOccurrences: 1,\n        $uidMap: {}\n      };\n    } else {\n      tokenDatum = tokenMap[token];\n      tokenDatum.$totalNumOccurrences++;\n    }\n\n    var uidMap = tokenDatum.$uidMap;\n\n    if (typeof uidMap[uid] !== 'object') {\n      tokenDatum.$numDocumentOccurrences++;\n      uidMap[uid] = {\n        $document: doc,\n        $numTokenOccurrences: 1\n      };\n    } else {\n      uidMap[uid].$numTokenOccurrences++;\n    }\n  }\n  /**\n   * @inheritDocs\n   */\n  ;\n\n  _proto.search = function search(tokens, corpus) {\n    var uidToDocumentMap = {};\n\n    for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {\n      var token = tokens[i];\n      var tokenMetadata = this._tokenMap[token]; // Short circuit if no matches were found for any given token.\n\n      if (!tokenMetadata) {\n        return [];\n      }\n\n      if (i === 0) {\n        var keys = Object.keys(tokenMetadata.$uidMap);\n\n        for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n          var uid = keys[j];\n          uidToDocumentMap[uid] = tokenMetadata.$uidMap[uid].$document;\n        }\n      } else {\n        var keys = Object.keys(uidToDocumentMap);\n\n        for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n          var uid = keys[j];\n\n          if (typeof tokenMetadata.$uidMap[uid] !== 'object') {\n            delete uidToDocumentMap[uid];\n          }\n        }\n      }\n    }\n\n    var documents = [];\n\n    for (var uid in uidToDocumentMap) {\n      documents.push(uidToDocumentMap[uid]);\n    }\n\n    var calculateTfIdf = this._createCalculateTfIdf(); // Return documents sorted by TF-IDF\n\n\n    return documents.sort(function (documentA, documentB) {\n      return calculateTfIdf(tokens, documentB, corpus) - calculateTfIdf(tokens, documentA, corpus);\n    });\n  };\n\n  _proto._createCalculateIdf = function _createCalculateIdf() {\n    var tokenMap = this._tokenMap;\n    var tokenToIdfCache = this._tokenToIdfCache;\n    return function calculateIdf(token, documents) {\n      if (!tokenToIdfCache[token]) {\n        var numDocumentsWithToken = typeof tokenMap[token] !== 'undefined' ? tokenMap[token].$numDocumentOccurrences : 0;\n        tokenToIdfCache[token] = 1 + Math.log(documents.length / (1 + numDocumentsWithToken));\n      }\n\n      return tokenToIdfCache[token];\n    };\n  };\n\n  _proto._createCalculateTfIdf = function _createCalculateTfIdf() {\n    var tokenMap = this._tokenMap;\n    var uidFieldName = this._uidFieldName;\n\n    var calculateIdf = this._createCalculateIdf();\n\n    return function calculateTfIdf(tokens, document, documents) {\n      var score = 0;\n\n      for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n        var token = tokens[i];\n        var inverseDocumentFrequency = calculateIdf(token, documents);\n\n        if (inverseDocumentFrequency === Infinity) {\n          inverseDocumentFrequency = 0;\n        }\n\n        var uid;\n\n        if (uidFieldName instanceof Array) {\n          uid = document && getNestedFieldValue(document, uidFieldName);\n        } else {\n          uid = document && document[uidFieldName];\n        }\n\n        var termFrequency = typeof tokenMap[token] !== 'undefined' && typeof tokenMap[token].$uidMap[uid] !== 'undefined' ? tokenMap[token].$uidMap[uid].$numTokenOccurrences : 0;\n        score += termFrequency * inverseDocumentFrequency;\n      }\n\n      return score;\n    };\n  };\n\n  return TfIdfSearchIndex;\n}();\n/**\n * Search index capable of returning results matching a set of tokens but without any meaningful rank or order.\n */\n\n\nvar UnorderedSearchIndex = /*#__PURE__*/function () {\n  function UnorderedSearchIndex() {\n    this._tokenToUidToDocumentMap = {};\n  }\n  /**\n   * @inheritDocs\n   */\n\n\n  var _proto = UnorderedSearchIndex.prototype;\n\n  _proto.indexDocument = function indexDocument(token, uid, doc) {\n    if (typeof this._tokenToUidToDocumentMap[token] !== 'object') {\n      this._tokenToUidToDocumentMap[token] = {};\n    }\n\n    this._tokenToUidToDocumentMap[token][uid] = doc;\n  }\n  /**\n   * @inheritDocs\n   */\n  ;\n\n  _proto.search = function search(tokens, corpus) {\n    var intersectingDocumentMap = {};\n    var tokenToUidToDocumentMap = this._tokenToUidToDocumentMap;\n\n    for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {\n      var token = tokens[i];\n      var documentMap = tokenToUidToDocumentMap[token]; // Short circuit if no matches were found for any given token.\n\n      if (!documentMap) {\n        return [];\n      }\n\n      if (i === 0) {\n        var keys = Object.keys(documentMap);\n\n        for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n          var uid = keys[j];\n          intersectingDocumentMap[uid] = documentMap[uid];\n        }\n      } else {\n        var keys = Object.keys(intersectingDocumentMap);\n\n        for (var j = 0, numKeys = keys.length; j < numKeys; j++) {\n          var uid = keys[j];\n\n          if (typeof documentMap[uid] !== 'object') {\n            delete intersectingDocumentMap[uid];\n          }\n        }\n      }\n    }\n\n    var keys = Object.keys(intersectingDocumentMap);\n    var documents = [];\n\n    for (var i = 0, numKeys = keys.length; i < numKeys; i++) {\n      var uid = keys[i];\n      documents.push(intersectingDocumentMap[uid]);\n    }\n\n    return documents;\n  };\n\n  return UnorderedSearchIndex;\n}();\n\nvar REGEX = /[^a-zа-яё0-9\\-']+/i;\n/**\n * Simple tokenizer that splits strings on whitespace characters and returns an array of all non-empty substrings.\n */\n\nvar SimpleTokenizer = /*#__PURE__*/function () {\n  function SimpleTokenizer() {}\n\n  var _proto = SimpleTokenizer.prototype;\n  /**\n   * @inheritDocs\n   */\n\n  _proto.tokenize = function tokenize(text) {\n    return text.split(REGEX).filter(function (text) {\n      return text;\n    } // Filter empty tokens\n    );\n  };\n\n  return SimpleTokenizer;\n}();\n/**\n * Stemming is the process of reducing search tokens to their root (or stem) so that searches for different forms of a\n * word will match. For example \"search\", \"searching\" and \"searched\" are all reduced to the stem \"search\".\n *\n * <p>This stemming tokenizer converts tokens (words) to their stem forms before returning them. It requires an\n * external stemming function to be provided; for this purpose I recommend the NPM 'porter-stemmer' library.\n *\n * <p>For more information see http : //tartarus.org/~martin/PorterStemmer/\n */\n\n\nvar StemmingTokenizer = /*#__PURE__*/function () {\n  /**\n   * Constructor.\n   *\n   * @param stemmingFunction Function capable of accepting a word and returning its stem.\n   * @param decoratedIndexStrategy Index strategy to be run after all stop words have been removed.\n   */\n  function StemmingTokenizer(stemmingFunction, decoratedTokenizer) {\n    this._stemmingFunction = stemmingFunction;\n    this._tokenizer = decoratedTokenizer;\n  }\n  /**\n   * @inheritDocs\n   */\n\n\n  var _proto = StemmingTokenizer.prototype;\n\n  _proto.tokenize = function tokenize(text) {\n    return this._tokenizer.tokenize(text).map(this._stemmingFunction);\n  };\n\n  return StemmingTokenizer;\n}();\n/**\n * Stop words list copied from Lunr JS.\n */\n\n\nvar StopWordsMap = {\n  a: true,\n  able: true,\n  about: true,\n  across: true,\n  after: true,\n  all: true,\n  almost: true,\n  also: true,\n  am: true,\n  among: true,\n  an: true,\n  and: true,\n  any: true,\n  are: true,\n  as: true,\n  at: true,\n  be: true,\n  because: true,\n  been: true,\n  but: true,\n  by: true,\n  can: true,\n  cannot: true,\n  could: true,\n  dear: true,\n  did: true,\n  'do': true,\n  does: true,\n  either: true,\n  'else': true,\n  ever: true,\n  every: true,\n  'for': true,\n  from: true,\n  'get': true,\n  got: true,\n  had: true,\n  has: true,\n  have: true,\n  he: true,\n  her: true,\n  hers: true,\n  him: true,\n  his: true,\n  how: true,\n  however: true,\n  i: true,\n  'if': true,\n  'in': true,\n  into: true,\n  is: true,\n  it: true,\n  its: true,\n  just: true,\n  least: true,\n  \"let\": true,\n  like: true,\n  likely: true,\n  may: true,\n  me: true,\n  might: true,\n  most: true,\n  must: true,\n  my: true,\n  neither: true,\n  no: true,\n  nor: true,\n  not: true,\n  of: true,\n  off: true,\n  often: true,\n  on: true,\n  only: true,\n  or: true,\n  other: true,\n  our: true,\n  own: true,\n  rather: true,\n  said: true,\n  say: true,\n  says: true,\n  she: true,\n  should: true,\n  since: true,\n  so: true,\n  some: true,\n  than: true,\n  that: true,\n  the: true,\n  their: true,\n  them: true,\n  then: true,\n  there: true,\n  these: true,\n  they: true,\n  'this': true,\n  tis: true,\n  to: true,\n  too: true,\n  twas: true,\n  us: true,\n  wants: true,\n  was: true,\n  we: true,\n  were: true,\n  what: true,\n  when: true,\n  where: true,\n  which: true,\n  'while': true,\n  who: true,\n  whom: true,\n  why: true,\n  will: true,\n  'with': true,\n  would: true,\n  yet: true,\n  you: true,\n  your: true\n}; // Prevent false positives for inherited properties\n\nStopWordsMap.constructor = false;\nStopWordsMap.hasOwnProperty = false;\nStopWordsMap.isPrototypeOf = false;\nStopWordsMap.propertyIsEnumerable = false;\nStopWordsMap.toLocaleString = false;\nStopWordsMap.toString = false;\nStopWordsMap.valueOf = false;\n/**\n * Stop words are very common (e.g. \"a\", \"and\", \"the\") and are often not semantically meaningful in the context of a\n * search. This tokenizer removes stop words from a set of tokens before passing the remaining tokens along for\n * indexing or searching purposes.\n */\n\nvar StopWordsTokenizer = /*#__PURE__*/function () {\n  /**\n   * Constructor.\n   *\n   * @param decoratedIndexStrategy Index strategy to be run after all stop words have been removed.\n   */\n  function StopWordsTokenizer(decoratedTokenizer) {\n    this._tokenizer = decoratedTokenizer;\n  }\n  /**\n   * @inheritDocs\n   */\n\n\n  var _proto = StopWordsTokenizer.prototype;\n\n  _proto.tokenize = function tokenize(text) {\n    return this._tokenizer.tokenize(text).filter(function (token) {\n      return !StopWordsMap[token];\n    });\n  };\n\n  return StopWordsTokenizer;\n}();\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/**\n * Simple client-side searching within a set of documents.\n *\n * <p>Documents can be searched by any number of fields. Indexing and search strategies are highly customizable.\n */\n\n\nvar Search = /*#__PURE__*/function () {\n  /**\n   * Array containing either a property name or a path (list of property names) to a nested value\n   */\n\n  /**\n   * Constructor.\n   * @param uidFieldName Field containing values that uniquely identify search documents; this field's values are used\n   *                     to ensure that a search result set does not contain duplicate objects.\n   */\n  function Search(uidFieldName) {\n    if (!uidFieldName) {\n      throw Error('js-search requires a uid field name constructor parameter');\n    }\n\n    this._uidFieldName = uidFieldName; // Set default/recommended strategies\n\n    this._indexStrategy = new PrefixIndexStrategy();\n    this._searchIndex = new TfIdfSearchIndex(uidFieldName);\n    this._sanitizer = new LowerCaseSanitizer();\n    this._tokenizer = new SimpleTokenizer();\n    this._documents = [];\n    this._searchableFields = [];\n  }\n  /**\n   * Override the default index strategy.\n   * @param value Custom index strategy\n   * @throws Error if documents have already been indexed by this search instance\n   */\n\n\n  var _proto = Search.prototype;\n  /**\n   * Add a searchable document to the index. Document will automatically be indexed for search.\n   * @param document\n   */\n\n  _proto.addDocument = function addDocument(document) {\n    this.addDocuments([document]);\n  }\n  /**\n   * Adds searchable documents to the index. Documents will automatically be indexed for search.\n   * @param document\n   */\n  ;\n\n  _proto.addDocuments = function addDocuments(documents) {\n    this._documents = this._documents.concat(documents);\n    this.indexDocuments_(documents, this._searchableFields);\n  }\n  /**\n   * Add a new searchable field to the index. Existing documents will automatically be indexed using this new field.\n   *\n   * @param field Searchable field or field path. Pass a string to index a top-level field and an array of strings for nested fields.\n   */\n  ;\n\n  _proto.addIndex = function addIndex(field) {\n    this._searchableFields.push(field);\n\n    this.indexDocuments_(this._documents, [field]);\n  }\n  /**\n   * Search all documents for ones matching the specified query text.\n   * @param query\n   * @returns {Array<Object>}\n   */\n  ;\n\n  _proto.search = function search(query) {\n    var tokens = this._tokenizer.tokenize(this._sanitizer.sanitize(query));\n\n    return this._searchIndex.search(tokens, this._documents);\n  }\n  /**\n   * @param documents\n   * @param _searchableFields Array containing property names and paths (lists of property names) to nested values\n   * @private\n   */\n  ;\n\n  _proto.indexDocuments_ = function indexDocuments_(documents, _searchableFields) {\n    this._initialized = true;\n    var indexStrategy = this._indexStrategy;\n    var sanitizer = this._sanitizer;\n    var searchIndex = this._searchIndex;\n    var tokenizer = this._tokenizer;\n    var uidFieldName = this._uidFieldName;\n\n    for (var di = 0, numDocuments = documents.length; di < numDocuments; di++) {\n      var doc = documents[di];\n      var uid;\n\n      if (uidFieldName instanceof Array) {\n        uid = getNestedFieldValue(doc, uidFieldName);\n      } else {\n        uid = doc[uidFieldName];\n      }\n\n      for (var sfi = 0, numSearchableFields = _searchableFields.length; sfi < numSearchableFields; sfi++) {\n        var fieldValue;\n        var searchableField = _searchableFields[sfi];\n\n        if (searchableField instanceof Array) {\n          fieldValue = getNestedFieldValue(doc, searchableField);\n        } else {\n          fieldValue = doc[searchableField];\n        }\n\n        if (fieldValue != null && typeof fieldValue !== 'string' && fieldValue.toString) {\n          fieldValue = fieldValue.toString();\n        }\n\n        if (typeof fieldValue === 'string') {\n          var fieldTokens = tokenizer.tokenize(sanitizer.sanitize(fieldValue));\n\n          for (var fti = 0, numFieldValues = fieldTokens.length; fti < numFieldValues; fti++) {\n            var fieldToken = fieldTokens[fti];\n            var expandedTokens = indexStrategy.expandToken(fieldToken);\n\n            for (var eti = 0, nummExpandedTokens = expandedTokens.length; eti < nummExpandedTokens; eti++) {\n              var expandedToken = expandedTokens[eti];\n              searchIndex.indexDocument(expandedToken, uid, doc);\n            }\n          }\n        }\n      }\n    }\n  };\n\n  _createClass(Search, [{\n    key: \"indexStrategy\",\n    set: function set(value) {\n      if (this._initialized) {\n        throw Error('IIndexStrategy cannot be set after initialization');\n      }\n\n      this._indexStrategy = value;\n    },\n    get: function get() {\n      return this._indexStrategy;\n    }\n    /**\n     * Override the default text sanitizing strategy.\n     * @param value Custom text sanitizing strategy\n     * @throws Error if documents have already been indexed by this search instance\n     */\n\n  }, {\n    key: \"sanitizer\",\n    set: function set(value) {\n      if (this._initialized) {\n        throw Error('ISanitizer cannot be set after initialization');\n      }\n\n      this._sanitizer = value;\n    },\n    get: function get() {\n      return this._sanitizer;\n    }\n    /**\n     * Override the default search index strategy.\n     * @param value Custom search index strategy\n     * @throws Error if documents have already been indexed\n     */\n\n  }, {\n    key: \"searchIndex\",\n    set: function set(value) {\n      if (this._initialized) {\n        throw Error('ISearchIndex cannot be set after initialization');\n      }\n\n      this._searchIndex = value;\n    },\n    get: function get() {\n      return this._searchIndex;\n    }\n    /**\n     * Override the default text tokenizing strategy.\n     * @param value Custom text tokenizing strategy\n     * @throws Error if documents have already been indexed by this search instance\n     */\n\n  }, {\n    key: \"tokenizer\",\n    set: function set(value) {\n      if (this._initialized) {\n        throw Error('ITokenizer cannot be set after initialization');\n      }\n\n      this._tokenizer = value;\n    },\n    get: function get() {\n      return this._tokenizer;\n    }\n  }]);\n\n  return Search;\n}();\n/**\n * This utility highlights the occurrences of tokens within a string of text. It can be used to give visual indicators\n * of match criteria within searchable fields.\n *\n * <p>For performance purposes this highlighter only works with full-word or prefix token indexes.\n */\n\n\nvar TokenHighlighter = /*#__PURE__*/function () {\n  /**\n   * Constructor.\n   *\n   * @param opt_indexStrategy Index strategy used by Search\n   * @param opt_sanitizer Sanitizer used by Search\n   * @param opt_wrapperTagName Optional wrapper tag name; defaults to 'mark' (e.g. <mark>)\n   */\n  function TokenHighlighter(opt_indexStrategy, opt_sanitizer, opt_wrapperTagName) {\n    this._indexStrategy = opt_indexStrategy || new PrefixIndexStrategy();\n    this._sanitizer = opt_sanitizer || new LowerCaseSanitizer();\n    this._wrapperTagName = opt_wrapperTagName || 'mark';\n  }\n  /**\n   * Highlights token occurrences within a string by wrapping them with a DOM element.\n   *\n   * @param text e.g. \"john wayne\"\n   * @param tokens e.g. [\"wa\"]\n   * @returns {string} e.g. \"john <mark>wa</mark>yne\"\n   */\n\n\n  var _proto = TokenHighlighter.prototype;\n\n  _proto.highlight = function highlight(text, tokens) {\n    var tagsLength = this._wrapText('').length;\n\n    var tokenDictionary = Object.create(null); // Create a token map for easier lookup below.\n\n    for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {\n      var token = this._sanitizer.sanitize(tokens[i]);\n\n      var expandedTokens = this._indexStrategy.expandToken(token);\n\n      for (var j = 0, numExpandedTokens = expandedTokens.length; j < numExpandedTokens; j++) {\n        var expandedToken = expandedTokens[j];\n\n        if (!tokenDictionary[expandedToken]) {\n          tokenDictionary[expandedToken] = [token];\n        } else {\n          tokenDictionary[expandedToken].push(token);\n        }\n      }\n    } // Track actualCurrentWord and sanitizedCurrentWord separately in case we encounter nested tags.\n\n\n    var actualCurrentWord = '';\n    var sanitizedCurrentWord = '';\n    var currentWordStartIndex = 0; // Note this assumes either prefix or full word matching.\n\n    for (var i = 0, textLength = text.length; i < textLength; i++) {\n      var character = text.charAt(i);\n\n      if (character === ' ') {\n        actualCurrentWord = '';\n        sanitizedCurrentWord = '';\n        currentWordStartIndex = i + 1;\n      } else {\n        actualCurrentWord += character;\n        sanitizedCurrentWord += this._sanitizer.sanitize(character);\n      }\n\n      if (tokenDictionary[sanitizedCurrentWord] && tokenDictionary[sanitizedCurrentWord].indexOf(sanitizedCurrentWord) >= 0) {\n        actualCurrentWord = this._wrapText(actualCurrentWord);\n        text = text.substring(0, currentWordStartIndex) + actualCurrentWord + text.substring(i + 1);\n        i += tagsLength;\n        textLength += tagsLength;\n      }\n    }\n\n    return text;\n  }\n  /**\n   * @param text to wrap\n   * @returns Text wrapped by wrapper tag (e.g. \"foo\" becomes \"<mark>foo</mark>\")\n   * @private\n   */\n  ;\n\n  _proto._wrapText = function _wrapText(text) {\n    var tagName = this._wrapperTagName;\n    return \"<\" + tagName + \">\" + text + \"</\" + tagName + \">\";\n  };\n\n  return TokenHighlighter;\n}();\n\nexport { AllSubstringsIndexStrategy, CaseSensitiveSanitizer, ExactWordIndexStrategy, LowerCaseSanitizer, PrefixIndexStrategy, Search, SimpleTokenizer, StemmingTokenizer, StopWordsMap, StopWordsTokenizer, TfIdfSearchIndex, TokenHighlighter, UnorderedSearchIndex };","import React, { useState, useEffect } from 'react';\nimport * as JsSearch from 'js-search';\n\nimport MasterLayout from '../layouts/MasterLayout';\n\nimport PageHero from '../components/common/PageHero'\nimport SearchBar from '../components/common/SearchBar';\nimport PostGrid from '../components/common/PostGrid';\n\nexport default ({ pageContext }) => {\n\n    /* state */\n    const [term, setTerm] = useState(null);\n    const [searchResults, setSearchResults] = useState([]);\n    const [searcher, setSearcher] = useState(null);\n\n    const onChangeHook = (newTerm) => {\n        setTerm(newTerm);\n    }\n\n    useEffect(() => {\n        /* URL param */\n        const params = new URLSearchParams(document.location.search.substring(1));\n        const queryString = params.get('s');\n        setTerm(queryString);\n\n        /* making post array */\n        let postArray = [];\n\n        pageContext.postData.allPosts.forEach(element => {\n            postArray.push({\n                ...element.node\n            })\n        });\n\n        /* setting searcher */\n        var search = new JsSearch.Search('id');\n        search.addIndex('title')\n        search.addIndex('content');\n\n        search.addDocuments(postArray);\n        setSearcher(search);\n\n        /* initial search */\n        setSearchResults(search.search(term));\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n\n    useEffect(() => {\n        if (searcher) {\n            setSearchResults(searcher.search(term));\n        }\n    }, [term, searcher]);\n\n    return (\n        <MasterLayout>\n            <section>\n                <PageHero text=\"Search\" />\n                <SearchBar onChangeHook={onChangeHook} />\n                <PostGrid\n                    title={\n                        term\n                            ? `${searchResults.length} results for '${term}'`\n                            : 'Search results'\n                    }\n\n                    itemArray={searchResults}\n                    itemsPerPage={2} />\n            </section>\n        </MasterLayout>\n    );\n}","import styled from 'styled-components';\n\nexport const PostGrid = styled.div`\n    padding: 12px 6px;\n\n    .cursor {\n        width: 100%;\n        margin-bottom: 16px;\n        display: flex;\n        align-items: center;\n        justify-content: flex-end;\n        font-size: 12px;\n        letter-spacing: 1px;\n\n        button {\n            padding: 3px 8px;\n            margin-left: 6px;\n            border: none;\n            border-radius: 5px;\n            cursor: pointer;\n            outline: none;\n            box-shadow: 2px 2px 4px 2px rgba(0,0,0,0.14);\n            transition: opacity 0.2s ease-out;\n            transition: box-shadow 0.2s ease-out;\n            user-select: none;\n\n            &:hover {\n                box-shadow: 2px 2px 5px 3px rgba(0,0,0,0.14);\n            }\n\n            &:active {\n                box-shadow: inset 2px 2px rgba(0,0,0,0.14);\n            }\n\n            &.disabled {\n                opacity: 0;\n                pointer-events: none;\n            }\n        }\n    }\n\n    li:not(:last-child) {\n        margin-bottom: 36px;\n    }\n\n    .thumbnail {\n        height: 300px;\n    }\n\n    @media(min-width: 1024px) {\n\n        ul {\n            display: flex;\n            flex-wrap: wrap;\n            justify-content: space-between;\n\n            li {\n                width: calc(50% - 16px);\n\n                &:last-child {\n                    margin-bottom: 36px;\n                }\n\n                &:last-child:nth-child(2n - 1) {\n                    width: 100%;\n                }\n\n                > * {\n                    height: 100%;\n                }\n            }\n        }\n    }\n`;","import styled from 'styled-components';\n\nexport const PostCard = styled.div`\n    border-radius: 5px;\n    box-shadow: 2px 2px 4px 2px rgba(0,0,0,0.3);\n    overflow: hidden;\n    transition: box-shadow 0.2s ease-out;\n\n    &:hover {\n        box-shadow: 2px 2px 5px 3px rgba(0,0,0,0.4);\n    }\n\n    .thumbnail {\n        position: relative;\n        &::after {\n            content: '';\n            position: absolute;\n            top: 0;\n            left: 0;\n\n            width: 100%;\n            height: 100%;\n            background-color: rgba(0,0,0,0.39);\n        }\n    }\n\n    .post-card-body {\n        padding: 24px 16px;\n\n        .category-wrapper {\n            display: flex;\n            flex-wrap: wrap;\n\n            a {\n                span {\n                    display: block;\n                    padding: 13px 16px;\n                    margin-bottom: 8px;\n                    border-radius: 16px;\n                    background-color: #C5CAE9;\n\n                    font-size: 12px;\n                    color: #000000;\n\n                    transition: box-shadow 0.2s ease-out;\n\n                    &:hover {\n                        box-shadow: 2px 2px 4px 2px rgba(0,0,0,0.14);\n                    }\n                }\n                &:not(:last-child) {\n                    margin-right: 8px;\n                }\n            }\n        }\n\n        .title {\n            margin: 16px 0;\n            color: #3F51B5;\n            font-size: 24px;\n        }\n\n        .excerpt {\n            font-size: 16px;\n        }\n    }\n`;","import React from 'react';\nimport { Link } from 'gatsby';\nimport Img from 'gatsby-image';\nimport { PostCard } from './PostCard.styled';\n\nimport { getPathname } from '../../../utils/getPathname';\n\n\nexport default ({ post }) => {\n\n    const { title, link, featured_media, categories, excerpt } = post;\n\n    return (\n        <PostCard>\n            {featured_media\n                ?   <Link to={getPathname(link)}>\n                        <Img\n                        className=\"thumbnail\"\n                        fluid={featured_media.localFile.childImageSharp.fluid}\n                        title={featured_media.title ? featured_media.title : title}\n                        alt={featured_media.alt_text ? featured_media.alt_text : title} />\n                    </Link>\n\n                :   null\n            }\n\n            <div className=\"post-card-body\">\n                <div className=\"category-wrapper\">\n                    {categories\n                        ? categories.map(item =>\n                            <Link to={getPathname(item.link)} key={item.id}>\n                                <span className=\"category-item\">{item.name}</span>\n                            </Link>\n                        )\n\n                        : null\n                    }\n                </div>\n\n                <Link to={getPathname(link)}>\n                    <h3 className=\"title\">{title}</h3>\n                </Link>\n\n                {excerpt\n                    ? <div className=\"excerpt\" dangerouslySetInnerHTML={{__html: excerpt}}></div>\n                    : null\n                }\n            </div>\n        </PostCard>\n    );\n}","import React, { useState, useEffect } from 'react';\n\nimport MaterialContainer from '../MaterialContainer';\nimport { PostGrid } from './PostGrid.styled';\nimport PostCard from '../PostCard';\n\nexport default ({ title, itemArray, itemsPerPage }) => {\n\n    if (itemsPerPage < 1 || itemsPerPage === undefined || itemsPerPage > itemArray.length) {\n        itemsPerPage = 1;\n    }\n\n    const slicePosts = (index) => {\n        return itemArray.slice(index * itemsPerPage, (index * itemsPerPage) + itemsPerPage);\n    }\n\n    const [index, setIndex] = useState(0);\n    const [postList, setPostlist] = useState(slicePosts(0));\n\n    useEffect(() => {\n        setPostlist(slicePosts(index));\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [itemArray])\n\n    useEffect(() => {\n        setPostlist(slicePosts(index));\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [index])\n\n    const handleSetIndex = (newValue) => {\n        if (newValue >= 0 && newValue < (itemArray.length / itemsPerPage)) {\n            setIndex(newValue);\n        }\n    }\n\n    return (\n        <MaterialContainer labelTag={title} container={true}>\n\n            <PostGrid>\n                <div className=\"cursor\">\n                    {`${index * itemsPerPage + (postList.length)} of ${itemArray.length} posts`}\n                    <button className={index === 0 ? `disabled` : ''} onClick={() => handleSetIndex(index - 1)}>{`<`}</button>\n                    <button className={index + 1 === Math.ceil(itemArray.length / itemsPerPage) ? `disabled` : ''} onClick={() => handleSetIndex(index + 1)}>{`>`}</button>\n                </div>\n\n                <ul>\n                    {postList.map(item => {\n\n                        let currentItem;\n\n                        if (item.node) {\n                            currentItem = item.node;\n                        } else {\n                            currentItem = item;\n                        }\n\n                        const { id } = currentItem;\n\n                        return (\n                            <li key={id}>\n                                <PostCard post={currentItem} />\n                            </li>\n                        )\n                    })}\n                </ul>\n            </PostGrid>\n        </MaterialContainer>\n    )\n}","import styled from 'styled-components';\n\nexport default styled.h2`\n    margin-top: 24px;\n\n    font-size: 32px;\n    text-align: center;\n    color: #3F51B5;\n    text-transform: uppercase;\n    letter-spacing: 2px;\n`;","import React from 'react';\nimport PageHero from './PageHero.styled';\n\nexport default ({ text }) => {\n    return <PageHero className=\"container\">{text}</PageHero>\n}","var React = require('react');\n\nfunction Search (props) {\n    return React.createElement(\"svg\",props,React.createElement(\"g\",null,[React.createElement(\"g\",{\"key\":0},React.createElement(\"g\",null,React.createElement(\"path\",{\"d\":\"M508.874,478.708L360.142,329.976c28.21-34.827,45.191-79.103,45.191-127.309c0-111.75-90.917-202.667-202.667-202.667    S0,90.917,0,202.667s90.917,202.667,202.667,202.667c48.206,0,92.482-16.982,127.309-45.191l148.732,148.732    c4.167,4.165,10.919,4.165,15.086,0l15.081-15.082C513.04,489.627,513.04,482.873,508.874,478.708z M202.667,362.667    c-88.229,0-160-71.771-160-160s71.771-160,160-160s160,71.771,160,160S290.896,362.667,202.667,362.667z\",\"fill\":\"#ffffff\",\"data-original\":\"#000000\",\"style\":{},\"className\":\"\"}))),React.createElement(\"g\",{\"key\":1}),React.createElement(\"g\",{\"key\":2}),React.createElement(\"g\",{\"key\":3}),React.createElement(\"g\",{\"key\":4}),React.createElement(\"g\",{\"key\":5}),React.createElement(\"g\",{\"key\":6}),React.createElement(\"g\",{\"key\":7}),React.createElement(\"g\",{\"key\":8}),React.createElement(\"g\",{\"key\":9}),React.createElement(\"g\",{\"key\":10}),React.createElement(\"g\",{\"key\":11}),React.createElement(\"g\",{\"key\":12}),React.createElement(\"g\",{\"key\":13}),React.createElement(\"g\",{\"key\":14}),React.createElement(\"g\",{\"key\":15})]));\n}\n\nSearch.defaultProps = {\"version\":\"1.1\",\"width\":\"14\",\"height\":\"14\",\"x\":\"0\",\"y\":\"0\",\"viewBox\":\"0 0 511.999 511.999\",\"style\":{\"enableBackground\":\"new 0 0 512 512\"},\"xmlSpace\":\"preserve\",\"className\":\"\"};\n\nmodule.exports = Search;\n\nSearch.default = Search;\n"],"sourceRoot":""}